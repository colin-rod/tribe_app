Absolutely—here’s a clear “handoff doc” you can paste straight into Claude Code to drive the pivot. I tailored it to your repo’s current structure (Next.js + Supabase; src/app, supabase/migrations, testing helpers, etc.).  ￼

⸻

Pivot Plan: “Tree + Branches” with Parent-Only Chatbot & Multi-Channel Delivery

0) Goals (what we’re changing)
	1.	Rename the domain model to Trees (households) and Branches (private sharing groups and community groups).
	2.	Keep Branches usable with or without a Tree (family branches under a Tree; community branches can be standalone).
	3.	Introduce a parent-only in-app chatbot (for capture, prompts, summaries).
	4.	Deliver updates to invitees via email now, with SMS/WhatsApp later, and web push for signed-in users.
	5.	Enforce Free vs Paid limits (invites, storage, video, retention).
	6.	Fix RLS pitfalls (remove self-referential recursion) and make access helpers explicit.

Repo reference for structure & tech: Next.js 15/React 19/TS + Supabase (auth/storage/RLS) with supabase/migrations/ and an existing RBAC test harness.  ￼

⸻

1) Database: migrations (create a new folder supabase/migrations/20250827_*)

Create these as separate migration files in this order.

1.1 Types & helper functions

20250827_01_types_and_helpers.sql

-- Enums (idempotent)
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'role_tree') THEN
    CREATE TYPE role_tree AS ENUM ('owner','caregiver','viewer');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'role_branch') THEN
    CREATE TYPE role_branch AS ENUM ('owner','admin','member');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'privacy_level') THEN
    CREATE TYPE privacy_level AS ENUM ('private','invite_only','public');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'branch_kind') THEN
    CREATE TYPE branch_kind AS ENUM ('family','community');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'invite_status') THEN
    CREATE TYPE invite_status AS ENUM ('pending','accepted','expired','revoked');
  END IF;
END $$;

-- RLS helper functions (SECURITY DEFINER to avoid recursive policies)
CREATE OR REPLACE FUNCTION public.is_tree_member(p_tree uuid, p_user uuid)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM tree_members tm
    WHERE tm.tree_id = p_tree AND tm.user_id = p_user
  );
$$;

CREATE OR REPLACE FUNCTION public.is_branch_member(p_branch uuid, p_user uuid)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM branch_members bm
    WHERE bm.branch_id = p_branch AND bm.user_id = p_user
  );
$$;

CREATE OR REPLACE FUNCTION public.is_tree_owner(p_tree uuid, p_user uuid)
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM tree_members tm
    WHERE tm.tree_id = p_tree AND tm.user_id = p_user AND tm.role = 'owner'
  );
$$;

-- Limits helpers (for plan gating later; simple stub)
CREATE OR REPLACE FUNCTION public.plan_is_paid(p_user uuid) RETURNS boolean
LANGUAGE sql
STABLE
AS $$
  SELECT COALESCE(
    (SELECT s.is_active
       FROM subscriptions s
      WHERE s.user_id = p_user
      ORDER BY s.created_at DESC
      LIMIT 1), false);
$$;

1.2 Rename legacy tables to new names (non-breaking; keep data)

20250827_02_rename_tables.sql

-- If old tables exist, rename them. Otherwise create fresh ones.
DO $$ BEGIN
  PERFORM 1 FROM information_schema.tables WHERE table_name='tribes';
  IF FOUND THEN
    ALTER TABLE public.tribes RENAME TO trees;
    -- fix FK names after renames if needed
  END IF;
END $$;

DO $$ BEGIN
  PERFORM 1 FROM information_schema.tables WHERE table_name='circles';
  IF FOUND THEN
    ALTER TABLE public.circles RENAME TO branches;
  END IF;
END $$;

DO $$ BEGIN
  PERFORM 1 FROM information_schema.tables WHERE table_name='tribe_members';
  IF FOUND THEN
    ALTER TABLE public.tribe_members RENAME TO tree_members;
  END IF;
END $$;

DO $$ BEGIN
  PERFORM 1 FROM information_schema.tables WHERE table_name='circle_members';
  IF FOUND THEN
    ALTER TABLE public.circle_members RENAME TO branch_members;
  END IF;
END $$;

-- Optional: posts -> entries for clarity; keep if you prefer "posts"
DO $$ BEGIN
  PERFORM 1 FROM information_schema.tables WHERE table_name='posts';
  IF FOUND THEN
    ALTER TABLE public.posts RENAME TO entries;
  END IF;
END $$;

1.3 Create/extend new columns & indexes

20250827_03_extend_schema.sql

-- Trees
ALTER TABLE public.trees
  ADD COLUMN IF NOT EXISTS description text,
  ADD COLUMN IF NOT EXISTS created_by uuid NOT NULL,
  ADD COLUMN IF NOT EXISTS location text,
  ADD COLUMN IF NOT EXISTS config jsonb DEFAULT '{}'::jsonb;

-- Branches (tree_id nullable to support community branches)
ALTER TABLE public.branches
  ADD COLUMN IF NOT EXISTS tree_id uuid NULL REFERENCES public.trees(id) ON DELETE CASCADE,
  ADD COLUMN IF NOT EXISTS kind branch_kind NOT NULL DEFAULT 'family',
  ADD COLUMN IF NOT EXISTS privacy privacy_level NOT NULL DEFAULT 'private',
  ADD COLUMN IF NOT EXISTS created_by uuid NOT NULL,
  ADD COLUMN IF NOT EXISTS created_at timestamptz NOT NULL DEFAULT now();

-- Branch indexes
CREATE INDEX IF NOT EXISTS idx_branches_tree_id ON public.branches(tree_id);
CREATE INDEX IF NOT EXISTS idx_branches_privacy ON public.branches(privacy);

-- Tree members
ALTER TABLE public.tree_members
  ADD COLUMN IF NOT EXISTS role role_tree NOT NULL DEFAULT 'viewer',
  ADD COLUMN IF NOT EXISTS joined_at timestamptz NOT NULL DEFAULT now();

CREATE UNIQUE INDEX IF NOT EXISTS ux_tree_members ON public.tree_members(tree_id, user_id);

-- Branch members
ALTER TABLE public.branch_members
  ADD COLUMN IF NOT EXISTS role role_branch NOT NULL DEFAULT 'member',
  ADD COLUMN IF NOT EXISTS added_at timestamptz NOT NULL DEFAULT now();

CREATE UNIQUE INDEX IF NOT EXISTS ux_branch_members ON public.branch_members(branch_id, user_id);

-- Entries (formerly posts)
ALTER TABLE public.entries
  ADD COLUMN IF NOT EXISTS branch_id uuid REFERENCES public.branches(id) ON DELETE CASCADE,
  ADD COLUMN IF NOT EXISTS author_id uuid NOT NULL,
  ADD COLUMN IF NOT EXISTS content text,
  ADD COLUMN IF NOT EXISTS media_urls text[] DEFAULT '{}',
  ADD COLUMN IF NOT EXISTS milestone_type text,
  ADD COLUMN IF NOT EXISTS milestone_date date,
  ADD COLUMN IF NOT EXISTS created_at timestamptz NOT NULL DEFAULT now();

CREATE INDEX IF NOT EXISTS idx_entries_branch ON public.entries(branch_id);
CREATE INDEX IF NOT EXISTS idx_entries_created ON public.entries(created_at DESC);

-- Children (for prompts & milestone tracking)
CREATE TABLE IF NOT EXISTS public.children (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tree_id uuid NOT NULL REFERENCES public.trees(id) ON DELETE CASCADE,
  name text NOT NULL,
  dob date,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Invites (can target a tree or a branch)
CREATE TABLE IF NOT EXISTS public.invites (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tree_id uuid NULL REFERENCES public.trees(id) ON DELETE CASCADE,
  branch_id uuid NULL REFERENCES public.branches(id) ON DELETE CASCADE,
  invited_by uuid NOT NULL,
  email text,
  phone text,
  role role_branch DEFAULT 'member',
  status invite_status NOT NULL DEFAULT 'pending',
  token text NOT NULL UNIQUE DEFAULT (gen_random_uuid())::text,
  expires_at timestamptz NOT NULL DEFAULT (now() + interval '7 days'),
  created_at timestamptz NOT NULL DEFAULT now(),
  accepted_at timestamptz
);

-- Chatbot message store (parent-only)
CREATE TABLE IF NOT EXISTS public.assistant_threads (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tree_id uuid NOT NULL REFERENCES public.trees(id) ON DELETE CASCADE,
  created_by uuid NOT NULL,
  title text,
  created_at timestamptz NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.assistant_messages (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  thread_id uuid NOT NULL REFERENCES public.assistant_threads(id) ON DELETE CASCADE,
  author text NOT NULL CHECK (author IN ('parent','assistant')),
  content text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Push subscriptions
CREATE TABLE IF NOT EXISTS public.push_subscriptions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  endpoint text NOT NULL,
  p256dh text NOT NULL,
  auth text NOT NULL,
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE(user_id, endpoint)
);

-- Outbox for multi-channel delivery
CREATE TABLE IF NOT EXISTS public.outbox (
  id bigint generated by default as identity primary key,
  branch_id uuid NOT NULL REFERENCES public.branches(id) ON DELETE CASCADE,
  entry_id uuid NULL REFERENCES public.entries(id) ON DELETE CASCADE,
  channel text NOT NULL CHECK (channel IN ('email','sms','push')),
  payload jsonb NOT NULL,
  status text NOT NULL DEFAULT 'queued',
  attempts int NOT NULL DEFAULT 0,
  last_error text,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Simple subscriptions table (stub; replace with Stripe starter if you prefer)
CREATE TABLE IF NOT EXISTS public.subscriptions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL,
  is_active boolean NOT NULL DEFAULT false,
  plan text NOT NULL DEFAULT 'free',
  created_at timestamptz NOT NULL DEFAULT now()
);

1.4 RLS policies (replace self-referential ones to avoid recursion)

20250827_04_rls.sql

ALTER TABLE public.trees ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tree_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.branches ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.branch_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.children ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.assistant_threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.assistant_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invites ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.push_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.outbox ENABLE ROW LEVEL SECURITY;

-- Trees
DROP POLICY IF EXISTS trees_select ON public.trees;
CREATE POLICY trees_select ON public.trees
  FOR SELECT USING (is_tree_member(id, auth.uid()) OR created_by = auth.uid());

DROP POLICY IF EXISTS trees_modify ON public.trees;
CREATE POLICY trees_modify ON public.trees
  FOR UPDATE USING (is_tree_owner(id, auth.uid()));

CREATE POLICY trees_insert ON public.trees
  FOR INSERT WITH CHECK (created_by = auth.uid());

-- Tree members
DROP POLICY IF EXISTS tree_members_all ON public.tree_members;
CREATE POLICY tree_members_select ON public.tree_members
  FOR SELECT USING (is_tree_member(tree_id, auth.uid()) OR user_id = auth.uid());

CREATE POLICY tree_members_insert ON public.tree_members
  FOR INSERT WITH CHECK (is_tree_owner(tree_id, auth.uid()) OR user_id = auth.uid());

CREATE POLICY tree_members_update ON public.tree_members
  FOR UPDATE USING (is_tree_owner(tree_id, auth.uid()) OR user_id = auth.uid());

CREATE POLICY tree_members_delete ON public.tree_members
  FOR DELETE USING (is_tree_owner(tree_id, auth.uid()) OR user_id = auth.uid());

-- Branches
DROP POLICY IF EXISTS branches_select ON public.branches;
CREATE POLICY branches_select ON public.branches
  FOR SELECT USING (
    (privacy = 'public')
    OR is_branch_member(id, auth.uid())
    OR (tree_id IS NOT NULL AND is_tree_member(tree_id, auth.uid()))
    OR created_by = auth.uid()
  );

CREATE POLICY branches_insert ON public.branches
  FOR INSERT WITH CHECK (
    created_by = auth.uid()
    AND (
      -- Family branch under a tree: must be owner/caregiver
      (tree_id IS NOT NULL AND is_tree_member(tree_id, auth.uid()))
      OR (tree_id IS NULL) -- Community
    )
  );

CREATE POLICY branches_update ON public.branches
  FOR UPDATE USING (created_by = auth.uid() OR (tree_id IS NOT NULL AND is_tree_owner(tree_id, auth.uid())));

-- Branch members
DROP POLICY IF EXISTS branch_members_all ON public.branch_members;
CREATE POLICY branch_members_select ON public.branch_members
  FOR SELECT USING (is_branch_member(branch_id, auth.uid()));

CREATE POLICY branch_members_insert ON public.branch_members
  FOR INSERT WITH CHECK (auth.uid() = user_id OR is_branch_member(branch_id, auth.uid()));

CREATE POLICY branch_members_update ON public.branch_members
  FOR UPDATE USING (is_branch_member(branch_id, auth.uid()));

CREATE POLICY branch_members_delete ON public.branch_members
  FOR DELETE USING (is_branch_member(branch_id, auth.uid()));

-- Entries
CREATE POLICY entries_select ON public.entries
  FOR SELECT USING (is_branch_member(branch_id, auth.uid()) OR created_by = auth.uid());

CREATE POLICY entries_insert ON public.entries
  FOR INSERT WITH CHECK (author_id = auth.uid() AND is_branch_member(branch_id, auth.uid()));

CREATE POLICY entries_update ON public.entries
  FOR UPDATE USING (author_id = auth.uid());

-- Children
CREATE POLICY children_all ON public.children
  FOR ALL USING (is_tree_member(tree_id, auth.uid()))
  WITH CHECK (is_tree_member(tree_id, auth.uid()));

-- Chatbot threads/messages (parent/admin only)
CREATE POLICY assistant_threads_all ON public.assistant_threads
  FOR ALL USING (is_tree_member(tree_id, auth.uid()))
  WITH CHECK (is_tree_member(tree_id, auth.uid()));

CREATE POLICY assistant_messages_select ON public.assistant_messages
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM assistant_threads t
      WHERE t.id = thread_id AND is_tree_member(t.tree_id, auth.uid())
    )
  );
CREATE POLICY assistant_messages_insert ON public.assistant_messages
  FOR INSERT WITH CHECK (
    author IN ('parent','assistant') AND
    EXISTS (
      SELECT 1 FROM assistant_threads t
      WHERE t.id = thread_id AND is_tree_member(t.tree_id, auth.uid())
    )
  );

-- Invites
CREATE POLICY invites_select ON public.invites
  FOR SELECT USING (invited_by = auth.uid()
    OR (tree_id IS NOT NULL AND is_tree_member(tree_id, auth.uid()))
    OR (branch_id IS NOT NULL AND is_branch_member(branch_id, auth.uid()))
  );
CREATE POLICY invites_insert ON public.invites
  FOR INSERT WITH CHECK (invited_by = auth.uid());

-- Push/outbox (owner-only reads)
CREATE POLICY push_subscriptions_all ON public.push_subscriptions
  FOR ALL USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

CREATE POLICY outbox_owner ON public.outbox
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM branches b
            JOIN branch_members bm ON bm.branch_id=b.id
           WHERE b.id=branch_id AND bm.user_id=auth.uid() AND bm.role IN ('owner','admin'))
  );

Note: This removes the self-join policy that previously caused “infinite recursion” on membership checks by never selecting from tree_members or branch_members inside their own policies. Instead we call SECURITY DEFINER helpers.

1.5 Triggers for email/push outbox

20250827_05_triggers.sql

-- When an entry is created on a branch with members, enqueue an email/push fanout
CREATE OR REPLACE FUNCTION public.enqueue_outbox_on_entry()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE
  member_id uuid;
BEGIN
  -- Email for non-app users; Push for signed-in users (client will register)
  FOR member_id IN SELECT user_id FROM branch_members WHERE branch_id = NEW.branch_id
  LOOP
    INSERT INTO outbox(branch_id, entry_id, channel, payload)
    VALUES (NEW.branch_id, NEW.id, 'email', jsonb_build_object('to_user_id', member_id));

    INSERT INTO outbox(branch_id, entry_id, channel, payload)
    VALUES (NEW.branch_id, NEW.id, 'push', jsonb_build_object('to_user_id', member_id));
  END LOOP;
  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS trg_entries_outbox ON public.entries;
CREATE TRIGGER trg_entries_outbox
AFTER INSERT ON public.entries
FOR EACH ROW EXECUTE FUNCTION public.enqueue_outbox_on_entry();


⸻

2) Backend/Edge Functions

2.1 Web Push (VAPID)
	•	Add env vars: VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY.
	•	Create Next.js API routes:
	•	src/app/api/push/subscribe/route.ts — upsert into push_subscriptions.
	•	src/app/api/push/send/route.ts — server action that pulls pending outbox rows with channel='push', fetches endpoints for target users, sends via web-push, updates status.

2.2 Email delivery
	•	Use Resend or SES via a Next.js Route Handler:
	•	src/app/api/email/send/route.ts — worker endpoint called by a CRON (Vercel Cron) to drain outbox where channel='email'.
	•	Store minimal template data in outbox.payload (entry id, branch id, summary text, deep link).

2.3 SMS (later)
	•	Create a Supabase Edge Function (functions/sms-worker/index.ts) using Twilio credentials; drain outbox with channel='sms'.

2.4 Chatbot
	•	Add src/app/(app)/assistant/ with:
	•	page.tsx (list threads per Tree)
	•	new and [threadId] routes
	•	Server actions call your preferred LLM provider (Vercel AI SDK or OpenAI) and persist messages in assistant_messages. Parents only (checked server-side via is_tree_member and role in tree_members).

⸻

3) Frontend changes (Next.js)

Your repo already has src/app/branches/ and a dashboard—extend, don’t rewrite.  ￼

	•	Navigation: Add “My Tree”, “Branches”, “Assistant”.
	•	Trees
	•	src/app/trees/ (household): settings, members, children (CRUD).
	•	Children UI: add DOB prompt, milestone presets; connects to Assistant prompts.
	•	Branches
	•	Keep existing list/detail. Add kind (family/community) and privacy flags.
	•	Invite flow can target a Tree (family) or a Branch directly (community).
	•	Composer
	•	In Branch detail, posting creates an entries row; a server action also creates outbox rows (or rely on DB trigger as above).
	•	Push
	•	Add public/sw.js and registration in a small hook (register on first sign-in).
	•	Subscribe endpoint posts to /api/push/subscribe.
	•	Free vs Paid gating
	•	At client entry/compose time, surface limits (e.g., “You’ve invited 10/10 free users”).
	•	On server actions, enforce again using plan_is_paid(auth.uid()).

⸻

4) Limits & Plans (app + guardrails)
	•	Free: max_branch_invites = 10; storage_retention_days = 90; no video; email/push allowed; SMS disabled.
	•	Paid: unlimited invites; infinite retention; video uploads; SMS; higher upload size.
	•	Implement a view plan_limits(user_id) in SQL or compute in server action; enforce:
	•	Before insert into branch_members: count current members; block if exceeding and not paid.
	•	Before media upload: check plan and mime/size.

⸻

5) Stripe (simple starter)
	•	Add subscriptions table already stubbed. Wire Stripe Checkout via:
	•	src/app/api/billing/create-checkout-session/route.ts
	•	Webhook src/app/api/billing/webhook/route.ts to set subscriptions.is_active=true & plan='pro'.

⸻

6) Data migration/backfill
	•	For existing data:
	•	trees: copy created_by from prior tribes.created_by.
	•	branches: set tree_id for what used to be “family” circles; set kind='family'. For community, set tree_id=NULL, kind='community'.
	•	entries: ensure branch_id populated from prior circle id.
	•	Recompute memberships: tree_members from prior tribe_members; branch_members from circle_members.

⸻

7) Testing updates (reuse your TESTING.md structure)
	•	Add tests for:
	•	Parent can create Tree, add caregivers, add children.
	•	Create family Branch under Tree; create community Branch without Tree.
	•	RLS: member can read their branch; non-member cannot.
	•	Posting an entry enqueues two outbox rows (email + push).
	•	Push subscription round-trip (register → test send).
	•	Free plan invite cap blocks the 11th invite.
	•	Retention job (cron) deletes Free entries older than 90 days.

⸻

8) Files & TODOs for Claude Code

Create/Modify
	1.	SQL
	•	Add the five migration files in supabase/migrations/20250827_* exactly as above.
	•	Run locally, then supabase gen types typescript --project-id <id> > src/types/database.ts.
	2.	Types
	•	Update src/types/database.ts (generated).
	•	Add src/types/plan.ts with a PlanLimits interface.
	3.	Assistant (parent-only)
	•	src/app/(app)/assistant/page.tsx (list threads)
	•	src/app/(app)/assistant/[threadId]/page.tsx
	•	src/app/(app)/assistant/actions.ts (server actions: create thread, add message, call LLM)
	•	Lock routes server-side: check is_tree_member and role IN ('owner','caregiver').
	4.	Trees
	•	src/app/(app)/trees/page.tsx (overview)
	•	src/app/(app)/trees/members.tsx (add/remove caregivers/viewers)
	•	src/app/(app)/trees/children.tsx (CRUD)
	5.	Branches
	•	Extend existing src/app/branches/* to show kind, privacy, and invite flows to Tree or Branch.
	6.	Composer & Fanout
	•	Ensure entry creation either:
	•	relies on DB trigger trg_entries_outbox, or
	•	calls a server action that inserts into outbox.
	7.	Push
	•	public/sw.js (basic web push handler).
	•	src/lib/push.ts helper (register/unregister).
	•	API routes: /api/push/subscribe & /api/push/send.
	8.	Email
	•	/api/email/send route that drains outbox (channel='email'); wire to Resend/SES via env.
	9.	Cron
	•	Vercel Cron to hit /api/email/send every minute (or 5); another cron for retention delete (Free plan).
	10.	Billing

	•	/api/billing/create-checkout-session & /api/billing/webhook (set subscriptions.is_active).

	11.	Env

	•	.env.local add: VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY, email provider keys, Stripe keys.

	12.	Feature gating

	•	Add a small src/lib/limits.ts reading plan_is_paid via RPC or from subscriptions and exposing booleans to UI.

	13.	RBAC tests

	•	Update test-rbac.js to reflect new function-based policies (is_tree_member, is_branch_member).

⸻

9) Rollout & safety
	•	Blue/Green: deploy DB migrations first; keep legacy names aliased until FE is updated.
	•	Backups: snapshot DB before renames.
	•	Observability: add simple logging on outbox workers; store last_error.

⸻

10) Known pitfalls & how we avoided them
	•	RLS infinite recursion: Removed policies that query the same table they protect; replaced with SECURITY DEFINER helpers.
	•	Public community branches: privacy='public' allows read discovery without membership; posting still requires membership.
	•	Plan enforcement: double-enforced (UI + server/SQL).
	•	Message fanout: queued through outbox so email/push can fail/retry without blocking a post.

⸻

If you want, I can also generate the exact Next.js route handler and minimal service worker skeletons for push + email so you can drop them in and iterate. The structure I referenced (folders, features) matches your repo’s current layout and README.  ￼